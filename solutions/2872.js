/*
문제를 풀 때는 먼저 여러 가지 예시를 직접 고려합니다.

[예시 1] 초기 값: [3, 2, 1]
1) 2를 꺼내서 위로 올리기
현재 상태: [2, 3, 1]
2) 1을 꺼내서 위로 올리기
현재 상태: [1, 2, 3]
정답: 2

[예시 2] 초기 값: [5, 6, 3, 4, 1, 2]
1) 4를 꺼내서 위로 올리기
현재 상태: [4, 5, 6, 3, 1, 2]
2) 3을 꺼내서 위로 올리기
현재 상태: [3, 4, 5, 6, 1, 2]
3) 2를 꺼내서 위로 올리기
현재 상태: [2, 3, 4, 5, 6, 1]
4) 1을 꺼내서 위로 올리기
현재 상태: [1, 2, 3, 4, 5, 6]

어떤 경우든 가장 큰 값은 위치를 옮길 필요가 없습니다.
그러면, 위치를 옮길 필요 없는 값들은 무엇일까요?

[핵심 아이디어] 뒤에서부터 보면서 가장 큰 값부터
내림차순으로 구성된 원소들은 위치를 바꿀 필요가 없습니다.

예시: [4, 1, 2, 5, 6, 3]
6 → 5 → 4으로 내림차순입니다. (연속될 필요 X)
[4, 5, 6]은 위치를 바꿀 필요가 없습니다.
정답: 3

예시: [4, 5, 1, 6, 7, 2, 3, 8]
8 → 7 → 6 → 5 → 4로 내림차순입니다. (연속될 필요 X)
[4, 5, 6, 7, 8]은 위치를 바꿀 필요가 없습니다.
정답: 3
*/

let fs = require('fs');
let input = fs.readFileSync('./input.txt').toString().split('\n');

let n = Number(input[0]); // 책의 개수 N 입력
let books = []; // 각 책의 번호 배열

for (let i = 1; i <= n; i++) {
  books.push(Number(input[i]));
}

// 가장 큰 값과 그 인덱스를 찾기
let maxValue = 0;
let maxIndex = -1;
for (let i = 0; i < n; i++) {
  if (maxValue < books[i]) {
    maxValue = books[i];
    maxIndex = i;
  }
}

// 뒤에서부터 출발해서 내림차순 배열의 크기를 계산
let length = 1;
let target = maxValue - 1;
for (let i = maxIndex - 1; i >= 0; i--) {
  if (target == books[i]) {
    target--;
    length++;
  }
}
console.log(n - length);
